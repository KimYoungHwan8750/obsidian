# 문자열

Java의 String이나 타입 선언을 하지 않는 언어들에선 문자열을 매우 쉽게 다룰 수 있다.

그러나 C/C++에선 문자열이 정말 문자들의 열(char\[])이라는 것을 실감할 수 있다.

```cpp
char str[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; // Hello\0
```

문자열이란, 문자(character)들의 집합이다. C에선 단순히 1바이트 배열의 나열이다. 종료문자 `\0`를 만나면 문자열의 끝을 알린다.

```cpp
char str[] = "Hello"; // 자동으로 크기가 6인 char[6] 배열 생성
```

C는 되는지 모르겠지만, C++에선 입력한 문자열 리터럴의 길이+1에 해당하는 char 배열이 자동으로 생성된다. 길이에 +1이 되는 이유는 종료 문자 `\0`이 자동으로 삽입되기 때문이다.

종료 문자, 말 그대로 배열의 끝을 표시하는 문자인데 그렇다면 다음과 같은 경우는 어떨까?

```cpp
char str1[100] = "hello \0world"; 
char str2[] = "hello \0world";

cout << "output: " << str1 << "\n" << "size: " << sizeof(str1) << endl;
cout << "output: " << str2 << "\n" << "size: " << sizeof(str2) << endl;
```

**결과**
```shell
output: hello
size: 100
output: hello
size: 13
```

명시적으로 사이즈를 지정해준 `str1`의 경우 size가 100, 자동으로 사이즈가 할당된 `str2`의 경우 입력한 문자 리터럴의 크기만큼 할당되었다.

`'h', 'e', 'l', 'l', 'o', ' ', '\0', 'w', 'o', 'r', 'l', 'd', '\0'`

누군가는 str2가 사이즈가 왜 13이냐고 물어볼수도 있겠다.

아까 말했듯 문자 리터럴로 배열을 초기화하면 문자열의 길이+1 사이즈만큼 크기가 할당이 된다. 그리고 종료문자로 인해 문자열 출력이 종료되어도 종료 문자 `\0`는 그대로 포함된다.

## char*
아마 C/C++ 소스코드를 보면 문자를 다룰 때 char\*를 쓰는 경우도 적잖게 볼 수 있는데, 이를 이해하기 위해서 배열과 메모리에 대해 알아두어야한다.

배열의 이름은, 배열의 시작 주소다.

1바이트 배열은 주소가 1바이트씩 연속적으로 이어지고,
4바이트 배열은 주소가 4바이트씩 연속적으로 이어진다.

```cpp
char str1[3] = { '1', '2', '\0' };
int str2[3] = {1, 2, 3};

for (int i = 0; i < 3; i++) {
	cout << "str1: " << (void*) &str1[i] << endl;
}
for (int i = 0; i < 3; i++) {
	cout << "str2: " << &str2[i] << endl;
}
```

(void \*)&str1\[i]는 메모리 주소를 출력하기 위해 형변환하였다.
cout는 타입이 char인 요소를 문자열로 변환하여 출력하기 때문이다.

```shell
str1: 000000838DAFFA64
str1: 000000838DAFFA65
str1: 000000838DAFFA66
str2: 000000838DAFFA88
str2: 000000838DAFFA8C
str2: 000000838DAFFA90
```

16진수로 출력된 메모리 주소를 보면 char 배열은 주소가 1바이트씩 연속적이고, int 배열은 4씩 연속적이다.

1. 000000838DAFFA88 // 여기서부터
2. 000000838DAFFA89
3. 000000838DAFFA8A
4. 000000838DAFFA8B // 여기까지 4바이트
5. 000000838DAFFA8C

이러한 점에서 출력 원리를 짐작해보자면 char\[100]을 콘솔에 출력하는 원리는 다음과 같지 않을까.

1. char str\[100]에서 길이100, 크기1Byte임을 알 수 있다.
2. 배열의 0번 인덱스를 방문하여 값을 출력하고 메모리 주소를 1Byte씩 이동한다.

정리해보면, 배열의 이름은 배열의 주소이고, 주소를 다루는 것은 포인터이다.

```cpp
int num[30] = { 1, 2 };
int *ptr = num; // 원시타입은 &num으로 전달하는데 배열은 num으로 전달한다. 다시 강조한다. *배열의 이름(num)*은 배열의 *주소*이다!

cout << num << endl; // 메모리 주소: 0x0000000000000000
cout << &num[0] << endl; // num과 같다, 메모리 주소: 0x0000000000000000과 같다.
cout << ptr << endl; // num과 같다, 메모리 주소: 0x0000000000000000과 같다.
```


## const char*, char*, char\[]
문자열을 다루면 세 가지 유형을 모두 겪어볼 수 있다.

const는 상수를 지정하는 것으로, 수정 불가능한 것을 명시할 때 사용하는 키워드이다.
그렇다면 const char\*를 왜 사용하는 걸까?

```cpp
char str1[5] = "1234\0";
str1[0] = 'h'; // h234\0

char *str2 = "1234\0";
str2[0] = 'h'; // Error
```

char\*는 문자열 리터럴 `"1234\0` 그 자체를 가리킨다.

이게 무슨 말이냐면, 문자열 리터럴 `"1234\0"`가 메모리에 할당되고, `"1234\0`을 참조하는 변수들은 같은 메모리 주소를 바라본다.

```cpp
const char *a = "hi";
const char *b = "hi";
cout << (void*)a << endl;
cout << (void*)b << endl;
```

각자 다른 변수에 똑같은 "hi"라는 값을 담아두고 메모리 주소를 출력해봤다.

```shell
00007FF75308AC54
00007FF75308AC54
```

같다. 그렇다면 이런 경우는?

```cpp
const char *a = "hi";
const char *b = "hi";
const char *c = "hello";
a = "hello";
cout << (void*)a << endl;
cout << (void*)b << endl;
cout << (void*)c << endl;
```

```shell
00007FF7A685AC50 # char *a : hi, 같다
00007FF7A685AC50 # char *b : hi, 같다
00007FF7A685AC54 # char *c : hello

00007FF7A685AC54 # char *a : hello, 같다
00007FF7A685AC50 # char *b : hi
00007FF7A685AC54 # char *c : hello, 같다
```

같은 문자열 리터럴을 바라보고 있는 두 변수의 메모리 참조값이 같다.