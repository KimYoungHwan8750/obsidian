## 배열
PHP5.6 같은 레거시 버전에서만 사용 가능한 문법으로, 배열의 키값을 따옴표로 감싸지 않아도 동작한다.

```php
<?php
$arr = [
    "abc"=>1
];

echo $arr[abc];
?>
```

즉 위와 같은 코드를 썼을 때 경고를 띄우기는 하나 `$arr[abc]`가 abc라는 변수를 찾고, 해당하는 변수가 없을시 이 abc를 문자열로 치환하며 정상 동작한다. 추가적인 연산이 발생해 속도도 느리고 이상한 동작으로 이어질 수 있는 위험한 방식이다.

## 보안 취약점
사용자가 Header에 슈퍼글로벌 키값을 보내 덮어쓸 수 있는 보안 취약점이 있다.

```php
$ext_arr = array ('SCRIPT_NAME', '_ENV', '_GET', '_POST', '_FILES', '_SERVER', '_COOKIE', '_SESSION', '_REQUEST',
                  'HTTP_ENV_VARS', 'HTTP_GET_VARS', 'HTTP_POST_VARS', 'HTTP_POST_FILES', 'HTTP_SERVER_VARS',
                  'HTTP_COOKIE_VARS', 'HTTP_SESSION_VARS', 'GLOBALS');
$ext_cnt = count($ext_arr);
for ($i=0; $i<$ext_cnt; $i++) {
    // POST, GET 으로 선언된 전역변수가 있다면 unset() 시킴
    if (isset($_GET[$ext_arr[$i]]))  unset($_GET[$ext_arr[$i]]);
    if (isset($_POST[$ext_arr[$i]])) unset($_POST[$ext_arr[$i]]);
}
```

위와 같은 형태로 해당 키값에 대한 데이터가 있을 시 이를 unset 시켜 보안 공격을 방어한다.

## GLOBALS 배열
전역에 선언한 변수는 모두 자동으로 GLOBALS에 담긴다. 이때 주의사항으로는 변수 앞의 $ 문자열은 제거된다는 것이다.

```php
$test = "abc";
$abc = 333;
echo $GLOBALS["test"]; // "abc"
echo $GLOBALS["$test"]; // "333"
```

$를 붙이게 되면 $abc가 되어서 333이 출력된다.

## 에러 제어 연산자
호출한 함수 이름 앞에 @를 붙이면 해당 함수에서 발생한 에러가 발생해도 아무일도 없었던 것처럼 코드가 진행된다.
