웹 개발에서 유명한 아키텍처 패턴들을 소개드리겠습니다.

## **1. Layered Architecture (계층형 아키텍처)**

가장 전통적이고 널리 사용되는 패턴입니다.

```java
// Presentation Layer
@RestController
public class UserController {
    private final UserService userService;
    
    @GetMapping("/users/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
}

// Business Layer
@Service
public class UserService {
    private final UserRepository userRepository;
    
    public UserResponse getUser(Long id) {
        User user = userRepository.findById(id);
        return UserResponse.from(user);
    }
}

// Data Access Layer
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

**특징:**
- Presentation → Business → Data Access → Database
- 각 계층은 바로 아래 계층만 의존
- 간단하고 이해하기 쉬움

## **2. Clean Architecture (클린 아키텍처)**

Uncle Bob이 제안한 아키텍처로, 의존성 역전 원칙을 강조합니다.

```java
// Domain Layer (Core)
public class User {
    private Long id;
    private String email;
    // 비즈니스 로직
}

// Application Layer (Use Cases)
public interface UserUseCase {
    UserResponse getUser(Long id);
}

@Service
public class UserUseCaseImpl implements UserUseCase {
    private final UserRepository userRepository;
    
    public UserResponse getUser(Long id) {
        User user = userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException(id));
        return UserResponse.from(user);
    }
}

// Interface Adapters
@RestController
public class UserController {
    private final UserUseCase userUseCase;
    
    @GetMapping("/users/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        return userUseCase.getUser(id);
    }
}

// Infrastructure
@Repository
public interface UserRepository {
    Optional<User> findById(Long id);
}
```

**특징:**
- 도메인이 중심, 외부 의존성 없음
- 의존성이 항상 안쪽(도메인)을 향함
- 테스트 용이성과 유지보수성 향상

## **3. Hexagonal Architecture (포트와 어댑터)**

Alistair Cockburn이 제안한 패턴으로, Clean Architecture와 유사합니다.

```java
// Domain (Core)
public class Order {
    private Long id;
    private OrderStatus status;
    
    public void confirm() {
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException("Cannot confirm order");
        }
        this.status = OrderStatus.CONFIRMED;
    }
}

// Port (Interface)
public interface OrderRepository {
    Order save(Order order);
    Optional<Order> findById(Long id);
}

public interface PaymentService {
    PaymentResult processPayment(Order order);
}

// Adapter (Implementation)
@Repository
public class JpaOrderRepository implements OrderRepository {
    private final JpaOrderEntityRepository jpaRepository;
    
    public Order save(Order order) {
        OrderEntity entity = OrderEntity.from(order);
        return jpaRepository.save(entity).toDomain();
    }
}

@Service
public class ExternalPaymentService implements PaymentService {
    public PaymentResult processPayment(Order order) {
        // 외부 결제 API 호출
    }
}
```

**특징:**
- 포트(인터페이스)와 어댑터(구현체) 분리
- 비즈니스 로직과 기술 구현 분리
- 다양한 어댑터로 교체 가능

## **4. Microservices Architecture (마이크로서비스)**

서비스를 작은 독립적인 단위로 분리합니다.

```java
// User Service
@RestController
@RequestMapping("/users")
public class UserController {
    @GetMapping("/{id}")
    public UserResponse getUser(@PathVariable Long id) {
        return userService.getUser(id);
    }
}

// Order Service
@RestController
@RequestMapping("/orders")
public class OrderController {
    private final UserServiceClient userServiceClient;
    
    @PostMapping
    public OrderResponse createOrder(@RequestBody OrderRequest request) {
        // 다른 서비스 호출
        UserResponse user = userServiceClient.getUser(request.getUserId());
        return orderService.createOrder(request, user);
    }
}

// Service Communication
@FeignClient(name = "user-service")
public interface UserServiceClient {
    @GetMapping("/users/{id}")
    UserResponse getUser(@PathVariable Long id);
}
```

**특징:**
- 각 서비스가 독립적으로 배포 가능
- 서비스 간 통신 (REST, gRPC, 메시지 큐)
- 확장성과 독립성이 높지만 복잡도 증가

## **5. Event-Driven Architecture (이벤트 기반)**

이벤트를 통해 서비스 간 통신합니다.

```java
// Event
public class OrderCreatedEvent {
    private Long orderId;
    private Long userId;
    private LocalDateTime createdAt;
}

// Event Publisher
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    
    public Order createOrder(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        
        // 이벤트 발행
        eventPublisher.publishEvent(
            new OrderCreatedEvent(order.getId(), order.getUserId())
        );
        
        return order;
    }
}

// Event Listener
@Component
public class NotificationService {
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        // 주문 생성 알림 전송
        sendNotification(event.getUserId(), "Order created: " + event.getOrderId());
    }
}

// Kafka Example
@Service
public class OrderEventProducer {
    private final KafkaTemplate<String, OrderCreatedEvent> kafkaTemplate;
    
    public void publishOrderCreated(OrderCreatedEvent event) {
        kafkaTemplate.send("order-events", event);
    }
}
```

**특징:**
- 느슨한 결합
- 비동기 처리
- 확장성과 유연성

## **6. CQRS (Command Query Responsibility Segregation)**

읽기와 쓰기를 분리합니다.

```java
// Command (쓰기)
public class CreateOrderCommand {
    private Long userId;
    private List<OrderItem> items;
}

@Service
public class OrderCommandService {
    private final OrderRepository orderRepository;
    private final EventPublisher eventPublisher;
    
    public OrderResponse createOrder(CreateOrderCommand command) {
        Order order = new Order(command);
        orderRepository.save(order);
        
        eventPublisher.publish(new OrderCreatedEvent(order));
        return OrderResponse.from(order);
    }
}

// Query (읽기)
public class OrderQuery {
    private Long userId;
    private LocalDate from;
    private LocalDate to;
}

@Service
public class OrderQueryService {
    private final OrderReadRepository readRepository;
    
    public List<OrderSummary> getOrders(OrderQuery query) {
        // 읽기 최적화된 저장소에서 조회
        return readRepository.findOrders(query);
    }
}
```

**특징:**
- 읽기/쓰기 모델 분리
- 각각 최적화 가능
- Event Sourcing과 함께 사용되기도 함

## **7. Serverless Architecture**

```javascript
// AWS Lambda Example
exports.handler = async (event) => {
    const userId = event.pathParameters.id;
    
    const user = await dynamoDB.get({
        TableName: 'Users',
        Key: { id: userId }
    }).promise();
    
    return {
        statusCode: 200,
        body: JSON.stringify(user.Item)
    };
};
```

**특징:**
- 서버 관리 불필요
- 사용한 만큼만 비용 지불
- 자동 스케일링

## **선택 기준**

- **소규모 프로젝트**: Layered Architecture
- **중규모, 도메인 중심**: Clean/Hexagonal Architecture
- **대규모, 독립 배포 필요**: Microservices
- **높은 확장성, 비동기**: Event-Driven
- **읽기/쓰기 부하 차이**: CQRS
- **빠른 개발, 운영 간소화**: Serverless

실무에서는 이들을 조합하여 사용하는 경우가 많습니다 (예: Microservices + Event-Driven + CQRS).