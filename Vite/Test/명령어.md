# 명령어

목차

* [describe와 it](#describe와%20it)
* [toBe와 toEqual](#toBe와%20toEqual)

## describe와 it


```ts

function add(x: number, y: number){
	return x+y
}
describe('add 함수 테스트', () => {
	it('1+1은 2', () => {
		expect(add(1, 1)).toBe(2)
	})

	it('음수를 포함한 덧셈 잘 되는지 동작 확인', () => {
		expect(add(-1, 1)).toBe(0)
	})
})
```

* `describe`: 테스트를 묶는 용도로 쓰인다.

* `it`: 테스트 케이스를 정의한다.

describe 안에 여러가지 테스트 케이스를 정의할 수 있다.

위 테스트 코드가 실행됐을 때 디렉토리 구조는 다음과 같이 그룹화된다.

>[!test] add 함수 테스트
>* 1+1은 2
>* 음수를 포함한 덧셈 잘 되는지 동작 확인

## toBe와 toEqual

```ts
it('test1', () => {
	expect([1]).toBe([1]) // fail
	expect([1]).toEqual([1]) // success
})
```

둘 다 어떤 값이 될 것으로 예측하는 테스트 함수다.

### toBe

엄격한 비교(\=\=\=)를 하는 함수다.
기본형(primitive) 값을 비교할 때 주로 사용되며 객체의 경우 참조가 같아야한다.

### toEqual

깊은 비교를 하는 함수다.
값이 같으면 참조가 달라도 테스트를 통과한다.


## 테스트 셋업 함수

* beforeEach: 현재 파일에 정의된 모든 테스트 케이스에 적용된다. 테스트 케이스 실행 전 작업을 정의할 수 있다.
* beforeAll: 현재 파일에 정의된 테스트 케이스에 대해 최초 1회에 한해 실행된다. beforeEach는 테스트 케이스 10개에 대해 10번 실행된다면, beforeAll은 10개든 100개든 1회만 실행된다.
* afterAll: 위와 같다. 테스트 코드가 실행된 후에 할 작업 정의.
* afterEach: 위와 같다.

## Function

### vi.fn()

jest.fn을 오마쥬한 함수.

`vi.fn(x: (args: any) => any)`형태로 사용 가능하다.
`const variable = vi.fn(() => 1)`와 같이 작성하면 `variable()`을 호출했을 때 1을 반환받는다.

```ts
import { describe, it, expect, vi } from "vitest";

describe('vitest', () => {
    it('test', () => {
        const result = vi.fn().mockImplementation(() => 1)

        result()
        expect(result).toHaveBeenCalledTimes(1) // OK

        result()
        expect(result).toHaveBeenCalledTimes(2) // OK

        result('5')
        expect(result).toBeCalledWith('5') // OK

        result('5')
        expect(result).not.toBeCalledWith(5) // OK

        console.log(result.mock.calls) // [ [], [], [ '5' ], [ '5' ] ]
        expect(result()).toBe(1) // OK

    })
})
```

### vi.fn().chainMethod

vi.fn() 하위에는 다양한 체인 메서드들이 존재한다.

#### vi.fn().mockImplementation()

`vi.fn()`을 구현한다.
`fn()`과 비교되는 주요 장점으로는 구현을 언제든지 덮어쓸 수 있다.

```ts
const fn = vi.fn().mockImplementation((x: number) => x+1)
fn(10) // 11

fn.mockImplementation((x: string) => '입력한 값: ' + x)
fn('홍길동') // 입력한 값: 홍길동
```

#### vi.fn().mockImplementationOnce()

단 한번의 호출에 대응하는 mock을 생성한다.

```ts
const fn = vi.fn().mockImplementationOnce(() => 1)
fn() // 1
fn() // undefined
fn() // undefined

const fnRedefine = vi.fn()
	.mockImplementation(() => 1)
	.mockImplementationOnce(() => 9999)

fnRedefine() // 9999
fnRedefine() // 1
fnRedefine() // 1

const fnReRedefine = vi.fn(() => 1)
	.mockImplementationOnce(() => 9999)

feReRedefine() // 9999
feReRedefine() // 1
feReRedefine() // 1
```

#### vi.fn().mockRestore()

spyOn 상태를 restore하는 경우와 fn()을 restore하는 경우 약간 다른 동작이 발생한다.

```ts
// Case 1
const fnRestore = vi.fn()
	.mockImplementation(() => 1)
	fnRestore() // 1

	fnRestore.mockImplementation(() => 2)
	fnRestore() // 2

	fnRestore.mockRestore()
	fnRestore() // undefined

// Case 2
const fnRestore = vi.fn(() => 0)
	.mockImplementation(() => 1)
	fnRestore() // 1

	fnRestore.mockImplementation(() => 2)
	fnRestore() // 2

	fnRestore.mockRestore()
	fnRestore() // 0
```

>[!warning] mockImplementation
>`mockImplementation()`은 기본적으로 빈 함수 `fn()`을 구현한 것이니 초기값은 fn()이 반환하는 값 `undefined`가 반환된다. 처음 호춣한 `mockImplementation(() => 구현)`으로 초기화되는 것으로 착각할 수도 있으니 주의할 것.

spyOn을 통해 구현한 함수는 원래 함수의 구현으로 초기화된다. 아래는 그 예시.

```ts
const myObj = {
	getOne(){
		return 1
	}
}
myObj.getOne() // 1

const spyOnMyObj = vi.spyOn(myObj, 'getOne')
	.mockImplementation(() => 9999)

myObj.getOne() // 9999

spyOnMyObj.mockRestore()

myObj.getOne() // 1

```


#### vi.fn().mockClear()

호출 기록을 제거한다.

```ts

// Case 1: 호출 카운트
const fn = vi.fn(() => 1)
fn() // 호출 카운트 + 1

expect(fn).toBeCalledTimes(1) // OK

fn.mockClear()

expect(fn).toBeCalledTimes(0) // OK
expect(fn).toBeCalledTimes(1) // ERROR

// Case 2: 호출 매개변수
const fn = vi.fn((x) => x+1)
fn(10) // CalledWith 10

expect(fn).toBeCalledWith(10) // OK

fn.mockClear()
expect(fn).toBeCalledWith(10) // ERROR


```

#### vi.fn().mockReset()

